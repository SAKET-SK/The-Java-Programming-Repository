<html><body>

<table width="100%"><tr>
<td>
<a href="http://www.bruceeckel.com/javabook.html">Bruce Eckel's Thinking in Java</a>
</td>
<td align="right">
<a href="tij_c.html">Contents</a> | <a href="tij0057.html">Prev</a> | <a href="tij0059.html">Next</a>
</td>
</tr></table>
<hr>

<H2 ALIGN=LEFT>
Java
access specifiers
</H2>
<DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">The
Java <A NAME="Index379"></A><A NAME="Index380"></A>access
specifiers <A NAME="Index381"></A></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>public</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">,
<A NAME="Index382"></A></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>protected</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
and <A NAME="Index383"></A></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>private</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
are placed in front of each definition for each member in your class, whether
it&#8217;s a data member or a method. Each access specifier controls the access
for only that particular definition. This is a distinct contrast to C++, in
which the access specifier controls all the definitions following it until
another access specifier comes along.
</FONT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">One
way or another, everything has some kind of access specified for it. In the
following sections, you&#8217;ll learn all about the various types of access,
starting with the default access.
</FONT><a name="_Toc312373840"></a><a name="_Toc375545296"></a><a name="_Toc408018500"></a><P></DIV>
<A NAME="Heading171"></A><H3 ALIGN=LEFT>
&#8220;Friendly&#8221;</H3>
<DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">What
if you give no access specifier at all, as in all the examples before this
chapter? The default access has no keyword, but it is commonly referred to as
&#8220;friendly.&#8221; It means that all the other classes in the current
package have access to the friendly member, but to all the classes outside of
this package the member appears to be private. Since a compilation unit &#8211;
a file &#8211; can belong only to a single package, all the classes within a
single compilation unit are automatically friendly with each other. Thus,
friendly elements are also said to have <A NAME="Index384"></A><A NAME="Index385"></A></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><I>package
access
</I></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">.</FONT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">Friendly
access allows you to group related classes together in a package so that they
can easily interact with each other. When you put classes together in a package
(thus granting mutual access to their friendly members; e.g. making them
&#8220;friends&#8221;) you &#8220;own&#8221; the code in that package. It makes
sense that only code that you own should have friendly access to other code
that you own. You could say that friendly access gives a meaning or a reason
for grouping classes together in a package. In many languages the way you
organize your definitions in files can be willy-nilly, but in Java you&#8217;re
compelled to <A NAME="Index386"></A><A NAME="Index387"></A>organize
them in a sensible fashion. In addition, you&#8217;ll probably want to exclude
classes that shouldn&#8217;t have access to the classes being defined in the
current package.
</FONT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">An
important question in any relationship is &#8220;Who can access my 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>private</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
implementation?&#8221; The class controls which code has access to its members.
There&#8217;s no magic way to &#8220;break in;&#8221; someone in another
package can&#8217;t declare a new class and say, &#8220;Hi, I&#8217;m a friend
of 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Bob</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">&#8217;s!&#8221;
and expect to see the 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>protected</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">,
friendly, and 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>private</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
members of 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Bob</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">.
The only way to grant access to a member is to:
</FONT><P></DIV>
<OL>
<LI><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">	Make
the member 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>public</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">.
Then everybody, everywhere, can access it.
</FONT><LI><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">	Make
the member friendly by leaving off any access specifier, and put the other
classes in the same package. Then the other classes can access the member.
</FONT><LI><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">	As
you&#8217;ll see in a later chapter where inheritance is introduced, an
inherited class can access a 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>protected</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
member as well as a 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>public</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
member (but not 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>private</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
members). It can access friendly members only if the two classes are in the
same package. But don&#8217;t worry about that now.
</FONT><LI><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">	Provide
&#8220;accessor/mutator&#8221; methods (also known as &#8220;get/set&#8221;
methods) that read and change the value. This is the most civilized approach in
terms of OOP, and it is fundamental to Java Beans, as you&#8217;ll see in
Chapter 13.
</FONT><a name="_Ref351419800"></a><a name="_Toc375545297"></a><a name="_Toc408018501"></a></OL><A NAME="Heading172"></A><H3 ALIGN=LEFT>
public:
interface access
</H3>
<DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">When
you use the 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>public</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
keyword, it <A NAME="Index388"></A>means
that the member declaration that immediately follows 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>public</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
is available to everyone, in particular to the client programmer who uses the
library. Suppose you define a package 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>dessert</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
containing the following compilation unit: (See page 
<A HREF=" PAGE#Running_programs">97</A>
if you have trouble executing this program.)
</FONT><P></DIV>

<font color="#990000"><PRE><font color="#009900">//: Cookie.java</font>
<font color="#009900">// Creates a library</font>
<font color="#0000ff">package</font> c05.dessert;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Cookie {
  <font color="#0000ff">public</font> Cookie() { 
   System.out.println("Cookie constructor"); 
  }
  <font color="#0000ff">void</font> foo() { System.out.println("foo"); }
} <font color="#009900">///:~ </PRE></font></font><DIV ALIGN=LEFT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">Remember,
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Cookie.java</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
must reside in a subdirectory called 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>dessert</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">,
in a directory under 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>C05
</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">(indicating
Chapter 5 of this book) that must be under one of the CLASSPATH directories.
Don&#8217;t make the mistake of thinking that Java will always look at the
current directory as one of the starting points for searching. If you
don&#8217;t have a &#8216;
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>.</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">&#8217;
as one of the paths in your CLASSPATH, Java won&#8217;t look there.
</FONT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">Now
if you create a program that uses 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Cookie</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">:</FONT><P></DIV>

<font color="#990000"><PRE><font color="#009900">//: Dinner.java</font>
<font color="#009900">// Uses the library</font>
<font color="#0000ff">import</font> c05.dessert.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> Dinner {
  <font color="#0000ff">public</font> Dinner() {
   System.out.println("Dinner constructor");
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Cookie x = <font color="#0000ff">new</font> Cookie();
    <font color="#009900">//! x.foo(); // Can't access</font>
  }
} <font color="#009900">///:~ </PRE></font></font><DIV ALIGN=LEFT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">You
can create a 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Cookie</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
object, since its constructor is 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>public</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
and the class is 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>public</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">.
(We&#8217;ll look more at the concept of a public class later.) However, the 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>foo(&#160;)</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
member is inaccessible inside 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Dinner.java</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
since 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>foo(&#160;)</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
is friendly only within package 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>dessert</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">.</FONT><P></DIV>
<A NAME="Heading173"></A><H4 ALIGN=LEFT>
The
default package
<P><A NAME="Index389"></A><A NAME="Index390"></A><A NAME="Index391"></A></H4>
<DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">You
might be surprised to discover that the following code compiles, even though it
would appear that it breaks the rules:
</FONT><P></DIV>

<font color="#990000"><PRE><font color="#009900">//: Cake.java</font>
<font color="#009900">// Accesses a class in a separate </font>
<font color="#009900">// compilation unit.</font>

<font color="#0000ff">class</font> Cake {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    Pie x = <font color="#0000ff">new</font> Pie();
    x.f();
  }
} <font color="#009900">///:~ </PRE></font></font><DIV ALIGN=LEFT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">In
a second file, in the same directory:
</FONT><P></DIV>

<font color="#990000"><PRE><font color="#009900">//: Pie.java</font>
<font color="#009900">// The other class</font>

<font color="#0000ff">class</font> Pie {
  <font color="#0000ff">void</font> f() { System.out.println("Pie.f()"); }
} <font color="#009900">///:~ </PRE></font></font><DIV ALIGN=LEFT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">You
might initially view these as completely foreign files, and yet 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Cake</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
is able to create a 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Pie</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
object and call its 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>f(&#160;)</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
method! You&#8217;d typically think that 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Pie</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
and 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>f(&#160;)</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
are friendly and therefore not available to 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Cake</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">.
They 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><I>are</I></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
friendly &#8211; that part is correct. The reason that they are available in 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Cake.java</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
is because they are in the same directory and have no explicit package name.
Java treats files like this as implicitly part of the &#8220;default
package&#8221; for that directory, and therefore friendly to all the other
files in that directory.
</FONT><a name="_Toc375545298"></a><a name="_Toc408018502"></a><P></DIV>
<A NAME="Heading174"></A><H3 ALIGN=LEFT>
private:
you can&#8217;t touch that!
</H3>
<DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">The
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>private</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
<A NAME="Index392"></A>keyword
that means no one can access that member except that particular class, inside
methods of that class. Other classes in the same package cannot access 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>private
</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">members,
so it&#8217;s as if you&#8217;re even insulating the class against yourself. On
the other hand, it&#8217;s not unlikely that a package might be created by
several people collaborating together, so 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>private</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
allows you to freely change that member without concern that it will affect
another class in the same package. The default &#8220;friendly&#8221; package
access is often an adequate amount of hiding; remember, a
&#8220;friendly&#8221; member is inaccessible to the user of the package. This
is nice, since the default access is the one that you normally use. Thus,
you&#8217;ll typically think about access for the members that you explicitly
want to make 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>public</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
for the client programmer, and as a result, you might not
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><I>
</I></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">initially
think you&#8217;ll use the 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>private
</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">keyword
often since it&#8217;s tolerable to get away without it. (This is a distinct
contrast with C++.) However, it turns out that the consistent use of 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>private</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
is very important, especially where multithreading is concerned. (As
you&#8217;ll see in Chapter 14.)
</FONT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">Here&#8217;s
an example of the use of 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>private</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">:</FONT><P></DIV>

<font color="#990000"><PRE><font color="#009900">//: IceCream.java</font>
<font color="#009900">// Demonstrates "private" keyword</font>

<font color="#0000ff">class</font> Sundae {
  <font color="#0000ff">private</font> Sundae() {}
  <font color="#0000ff">static</font> Sundae makeASundae() { 
    <font color="#0000ff">return</font> <font color="#0000ff">new</font> Sundae(); 
  }
}

<font color="#0000ff">public</font> <font color="#0000ff">class</font> IceCream {
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    <font color="#009900">//! Sundae x = new Sundae();</font>
    Sundae x = Sundae.makeASundae();
  }
} <font color="#009900">///:~ </PRE></font></font><DIV ALIGN=LEFT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">This
shows an example in which 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>private</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
comes in handy: you might want to control how an object is created and prevent
someone from directly accessing a particular constructor (or all of them). In
the example above, you cannot create a 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Sundae</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
object via its constructor; instead you must call the 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>makeASundae(&#160;)</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
method to do it for you.
</FONT><A NAME="fnB25" HREF="#fn25">[25]</A><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">Any
method that you&#8217;re certain is only a &#8220;helper&#8221; method for that
class can be made 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>private</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
to ensure that you don&#8217;t accidentally use it elsewhere in the package and
thus prohibit you from changing or removing the method. Making a method 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>private</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
guarantees that you retain this option. (However, just because the handle is 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>private</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
doesn't mean that some other object can't have a 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>public</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
handle to the same object. See Chapter 12 for issues about aliasing.)
</FONT><a name="_Toc312373839"></a><a name="_Toc375545299"></a><a name="_Toc408018503"></a><P></DIV>
<A NAME="Heading175"></A><H3 ALIGN=LEFT>
protected:
&#8220;sort of friendly&#8221;
</H3>
<DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">The
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>protected</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
access specifier requires a jump ahead to understand<A NAME="Index393"></A>.
First, you should be aware that you don&#8217;t need to understand this section
to continue through the book up through the inheritance chapter. But for
completeness, here is a brief description and example using 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>protected</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">.
</FONT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">The
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>protected</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
keyword deals with a concept called <A NAME="Index394"></A></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><I>inheritance</I></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">,
which takes an existing class and adds new members to that class without
touching the existing class, which we refer to as the <A NAME="Index395"></A><A NAME="Index396"></A></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><I>base</I></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><I>class</I></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">.
You can also change the behavior of existing members of the class. To inherit
from an existing class, you say that your new class <A NAME="Index397"></A></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>extends
</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">an
existing class, like this:
</FONT><P></DIV><DIV ALIGN=LEFT><TT><FONT FACE="Courier New" SIZE=3 COLOR="Black">class
Foo extends Bar {
</FONT></TT><P></DIV><DIV ALIGN=LEFT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">The
rest of the class definition looks the same.
</FONT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">If
you create a new package and you inherit from a class in another package, the
only members you have access to are the 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>public</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
members of the original package. (Of course, if you perform the inheritance in
the 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><I>same</I></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
package, you have the normal package access to all the &#8220;friendly&#8221;
members.) Sometimes the creator of the base class would like to take a
particular member and grant access to derived classes but not the world in
general. That&#8217;s what 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>protected</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
does. If you refer back to the file 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Cookie.java</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
on page 
<A HREF=" PAGE#_Ref351419800">203</A>,
the following class 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><I>cannot</I></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
access the &#8220;friendly&#8221; member:
</FONT><P></DIV>

<font color="#990000"><PRE><font color="#009900">//: ChocolateChip.java</font>
<font color="#009900">// Can't access friendly member</font>
<font color="#009900">// in another class</font>
<font color="#0000ff">import</font> c05.dessert.*;

<font color="#0000ff">public</font> <font color="#0000ff">class</font> ChocolateChip <font color="#0000ff">extends</font> Cookie {
  <font color="#0000ff">public</font> ChocolateChip() {
   System.out.println(
     "ChocolateChip constructor");
  }
  <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main(String[] args) {
    ChocolateChip x = <font color="#0000ff">new</font> ChocolateChip();
    <font color="#009900">//! x.foo(); // Can't access foo</font>
  }
} <font color="#009900">///:~ </PRE></font></font><DIV ALIGN=LEFT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">One
of the interesting things about inheritance is that if a method 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>foo(&#160;)</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
exists in class 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Cookie</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">,
then it also exists in any class inherited from 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Cookie</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">.
But since 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>foo(&#160;)</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
is &#8220;friendly&#8221; in a foreign package, it&#8217;s unavailable to us in
this one. Of course, you could make it 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>public</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">,
but then everyone would have access and maybe that&#8217;s not what you want.
If we change the class 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Cookie</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
as follows:
</FONT><P></DIV>

<font color="#990000"><PRE><font color="#0000ff">public</font> <font color="#0000ff">class</font> Cookie {
  <font color="#0000ff">public</font> Cookie() { 
    System.out.println("Cookie constructor");
  }
  <font color="#0000ff">protected</font> <font color="#0000ff">void</font> foo() {
    System.out.println("foo"); 
  }
}</PRE></font><DIV ALIGN=LEFT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">then
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>foo(&#160;)</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
still has &#8220;friendly&#8221; access within package 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>dessert</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">,
but it is also accessible to anyone inheriting from 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>Cookie</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">.
However, it is 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><I>not</I></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>public</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">.</FONT><a name="_Toc375545301"></a><a name="_Toc408018504"></a><P></DIV>
<HR><DIV ALIGN=LEFT><A NAME="fn25" HREF="#fnB25">[25]</A><FONT FACE="Carmina Md BT" SIZE=2 COLOR="Black">
There&#8217;s another effect in this case: Since the default constructor is the
only one defined, and it&#8217;s 
</FONT><FONT FACE="Carmina Md BT" SIZE=2 COLOR="Black"><B>private</B></FONT><FONT FACE="Carmina Md BT" SIZE=2 COLOR="Black">,
it will prevent inheritance of this class. (A subject that will be introduced
in Chapter 6.)
</FONT><P></DIV>


<div align="right">
<a href="tij_c.html">Contents</a> | <a href="tij0057.html">Prev</a> | <a href="tij0059.html">Next</a>
</div>
</body></html>

