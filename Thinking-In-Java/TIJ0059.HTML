<html><body>

<table width="100%"><tr>
<td>
<a href="http://www.bruceeckel.com/javabook.html">Bruce Eckel's Thinking in Java</a>
</td>
<td align="right">
<a href="tij_c.html">Contents</a> | <a href="tij0058.html">Prev</a> | <a href="tij0060.html">Next</a>
</td>
</tr></table>
<hr>

<H2 ALIGN=LEFT>
Interface
and implementation
</H2>
<DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">Access
control is often referred to as 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><I>implementation
hiding<A NAME="Index398"></A><A NAME="Index399"></A></I></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">.
Wrapping data and methods within classes (combined with implementation hiding
this is often called 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><I>encapsulation<A NAME="Index400"></A></I></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">)
produces a data type with characteristics and behaviors, but access control
puts boundaries within that data type for two important reasons. The first is
to establish what the client programmers can and can&#8217;t use. You can build
your internal mechanisms into the structure without worrying that the client
programmers will think it&#8217;s part of the interface that they should be
using.
</FONT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">This
feeds directly into the second reason, which is to separate the interface from
the implementation. <A NAME="Index401"></A><A NAME="Index402"></A><A NAME="Index403"></A>
If the structure is used in a set of programs, but users can&#8217;t do
anything but send messages to the 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>public</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
interface, then you can change anything that&#8217;s 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><I>not</I></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>public</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
(e.g. &#8220;friendly,&#8221; 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>protected</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">,
or 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>private</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">)
without requiring modifications to their code.
</FONT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">We&#8217;re
now in the world of object-oriented programming, where a 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>class</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
is actually describing &#8220;a class of objects,&#8221; as you would describe
a class of fishes or a class of birds. Any object belonging to this class will
share these characteristics and behaviors. The class is a description of the
way all objects of this type will look and act.
</FONT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">In
the original OOP <A NAME="Index404"></A>language,
Simula-67<A NAME="Index405"></A>,
the keyword 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>class</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
<A NAME="Index406"></A>was
used to describe a new data type. The same keyword has been used for most
object-oriented languages. This is the focal point of the whole language: the
creation of new data types that are more than just boxes containing data and
methods.
</FONT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">The
class is the fundamental OOP concept in Java. It is one of the keywords that
will 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><I>not
</I></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">be
set in bold in this book &#8211; it becomes annoying with a word repeated as
often as &#8220;class.&#8221;
</FONT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">For
clarity, you might prefer a <A NAME="Index407"></A><A NAME="Index408"></A>style
of creating classes that puts the 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>public</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
members at the beginning, followed by the 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>protected</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">,
friendly and 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>private</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
members. The advantage is that the user of the class can then read down from
the top and see first what&#8217;s important to them (the 
</FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><B>public</B></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">
members, because they can be accessed outside the file) and stop reading when
they encounter the non-public members, which are part of the internal
implementation. However, with the comment documentation supported by javadoc
(described in Chapter 2) the issue of code readability by the client programmer
becomes less important.
</FONT><P></DIV>

<font color="#990000"><PRE><font color="#0000ff">public</font> <font color="#0000ff">class</font> X {
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> pub1(&#160;) { <font color="#009900">/* . . . */</font> }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> pub2(&#160;) { <font color="#009900">/* . . . */</font> }
  <font color="#0000ff">public</font> <font color="#0000ff">void</font> pub3(&#160;) { <font color="#009900">/* . . . */</font> } </TT><P><TT><FONT FACE="Courier New" SIZE=3 COLOR="Black">  <font color="#0000ff">private</font> <font color="#0000ff">void</font> priv1(&#160;) { <font color="#009900">/* . . . */</font> } </TT><P><TT><FONT FACE="Courier New" SIZE=3 COLOR="Black">  <font color="#0000ff">private</font> <font color="#0000ff">void</font> priv2(&#160;) { <font color="#009900">/* . . . */</font> } </TT><P><TT><FONT FACE="Courier New" SIZE=3 COLOR="Black">  <font color="#0000ff">private</font> <font color="#0000ff">void</font> priv3(&#160;) { <font color="#009900">/* . . . */</font> } </TT><P><TT><FONT FACE="Courier New" SIZE=3 COLOR="Black">  <font color="#0000ff">private</font> <font color="#0000ff">int</font> i; </TT><P><TT><FONT FACE="Courier New" SIZE=3 COLOR="Black">  <font color="#009900">// . . . </TT><P><TT><FONT FACE="Courier New" SIZE=3 COLOR="Black">}</PRE></font></font><DIV ALIGN=LEFT><P></DIV><DIV ALIGN=LEFT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">This
will make it only partially easier to read because the interface and
implementation are still mixed together. That is, you still see the source code
&#8211; the implementation &#8211; because it&#8217;s right there in the class.
Displaying the interface to the consumer of a class is really the job of the <A NAME="Index409"></A><A NAME="Index410"></A></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black"><I>class
browser
</I></FONT><FONT FACE="Carmina Md BT" SIZE=3 COLOR="Black">,
a tool whose job is to look at all the available classes and show you what you
can do with them (i.e. what members are available) in a useful fashion. By the
time you read this, good browsers should be an expected part of any good Java
development tool.
</FONT><a name="_Toc375545302"></a><a name="_Toc408018505"></a><a name="_Toc312373850"></a><P></DIV>

<div align="right">
<a href="tij_c.html">Contents</a> | <a href="tij0058.html">Prev</a> | <a href="tij0060.html">Next</a>
</div>
</body></html>

